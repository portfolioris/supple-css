/*  =========================================================================
    tools.responsive
    desc
    ========================================================================= */

/*  Use/Forward rules
    `@use` or `@forward` everything you need here from other files.
    These can include variables, mixins & other includes.
    ========================================================================= */

@use 'sass:list';
@use 'sass:math';
@use 'sass:map';
@use 'sass:meta';
@use 'sass:string';
@use '../settings/defaults';
@use '../vendor/sass-mq/mq' as sassmq;
@use '_internal/functions';
@use 'rem';



/*  Wrappers to sass-mq
    ========================================================================= */

@mixin mq($args...) {
  @include sassmq.mq($args...) {
    @content;
  }
}

@mixin add-breakpoint($args...) {
  @include sassmq.mq-add-breakpoint($args...);
}

@mixin show-breakpoints($args...) {
  @include sassmq.mq-show-breakpoints($args...);
}



/*  supple-mq
    A little wrapper around sass-mq which alows us to pass in a string based
    direction instead of direction variable.

    Example usage:
    @include supple-mq(wall, until) {
      outline: 1px solid #ff0000;
    }
    ========================================================================= */

@mixin supple-mq($name, $direction: from) {
  @if ($direction == from) {
    @include mq($from: $name) {
      @content;
    }
  } @else if ($direction == until) {
    @include mq($until: $name) {
      @content;
    }
  } @else {
    @error '#{$direction} is not a valid sass-mq direction';
  }
}



/*  Rewritten MQ system
    ========================================================================= */

@mixin new-mq($query, $type: all) {
  @if not map.has-key(defaults.$breakpoints-test, $query) {
    @error '#{$queries} does not contain #{$query}';
  }

  $collection: get-breakpoints(map.get(defaults.$breakpoints-test, $query), $type);

  @media #{map.get($collection, type)} and #{map.get($collection, media-string)} {
    @content;
  }
}

/**
 * get-breakpoints
 * Returns a map with 2 keys
 * type: Media type
 * media-string: media query string
 */
@function get-breakpoints($queries, $type: all) {
  $breakpoints: defaults.$breakpoints-test;
  $media-string: ();
  $return: ();
  $media-map: parse-breakpoints($queries);

  @each $key, $value in $media-map {
    @if $value and $value != 0 {
      @if $media-string == (()) {
        $media-string: list.append($media-string, string.unquote('(#{$key}: #{$value})'));
      }

      @else {
        $media-string: list.append($media-string, string.unquote('and (#{$key}: #{$value})'));
      }
    }
  }
  $return: (
    type: $type,
    media-string: functions.implode($media-string),
  );

  @return $return;
}

/**
 * parse-breakpoints
 */
@function parse-breakpoints($queries) {
  $breakpoints: defaults.$breakpoints-test;
  $return: ();
  $i: 1;
  $minw: null;
  $maxw: null;
  $minh: null;
  $maxh: null;
  $length: list.length($queries);

  // Checks for width queries
  $minw: list.nth($queries, 1);
  $minw: validate($minw);

  // Check for width queries
  @if $minw {
    $minw: convert-to-em($minw);
    $return: map.merge($return, (min-width: $minw));
    $queries: list.set-nth($queries, 1, null);
  }

  // Checks if there is a max width query
  @if $minw and $length >= 2 {
    $maxw: list.nth($queries, 2);
    $maxw: validate($maxw);
  }

  @if $maxw {
    $maxw: convert-to-em($maxw - 1px);
    $return: map.merge($return, (max-width: $maxw));
    $queries: list.set-nth($queries, 2, null);
  }

  // Checks for height queries
  $h: list.index($queries, h) or list.index($queries, height);

  @if $h {
    $minh: list.nth($queries, $h + 1);
    $minh: validate($minh);

    @if $minh {
      $minh: convert-to-em($minh);
      $return: map.merge($return, (min-height: $minh));
      $queries: list.set-nth($queries, $h + 1, null);
    }

    // Checks if there is a max height query
    @if $length - $h >= 2 {
      $maxh: list.nth($queries, $h + 2);
      $maxh: validate($maxh);
    }

    @if $maxh {
      $maxh: convert-to-em($maxh - 1px);
      $return: map.merge($return, (max-height: $maxh));
      $queries: list.set-nth($queries, $h + 2, null);
    }
    // Reset h marker
    $queries: list.set-nth($queries, $h, null);
  }

  // Checks for other queries
  @while $i <= list.length($queries) {
    $key: list.nth($queries, $i);

    @if $key and $length - $i >= 1 {
      $val: list.nth($queries, $i + 1);
      $return: map.merge($return, (#{$key}: $val));
      $queries: list.set-nth($queries, $i, null);
      $queries: list.set-nth($queries, $i + 1, null);
    }

    @else if $key {
      @warn string.unquote('Breakpoints is missing value for media feature "#{$key}"');
    }
    $i: $i + 1;
  }
  @return $return;
}

/**
 * validate
 * Checks if $query given is one of the following:
 * - Is a $key in the $breakpoints map
 * - Is a number
 * - Is a "max", "max-width" or "max-height" string
 */
@function validate($query) {
  $breakpoints: defaults.$breakpoints-test;
  $return: null;

  @if meta.type-of($query) == string {
    @if map.has-key($breakpoints, $query) {
      $queryValue: map.get($breakpoints, $query);

      @if $queryValue == $query {
        @error 'Uh, oh! The value "#{$queryValue}" is the same as key "#{$query}", you cannot set the value to its own key.';
      } @else if meta.type-of($queryValue) != list {
        $return: $queryValue;
      } @else {
        @error 'Uh, oh! "#{$query}" does not contain a single value, you cannot use a key with a list as value here.';
      }
    } @else if $query == 'max' or $query == 'max-height' or $query == 'max-width' {
      $return: 0;
    } @else {
      @error 'Uh, oh! "#{$query}" is not available in defaults.$breakpoints-test';
    }
  }

  @else if meta.type-of($query) == number {
    $return: $query;
  }

  @else {
    $return: null;
  }
  @return $return;
}

/**
 * convert-to-em
 */
@function convert-to-em($val) {
  @if math.unit($val) == 'px' or $val == 0 {
    @return functions.value-to-em($val);
  }
  @else if math.unit($val) == 'em' {
    @return $val;
  }
  @else if math.unit($val) == 'rem' {
    @return functions.strip-unit($val) * 1em;
  }
  @else {
    @error 'Breakpoint value must have a unit if itâ€™s a number';
  }
}



/*  Clamp
    Basic usage:

    font-size: responsive.clamp(18px, 24px);

    This will scale the property perfectly and smooth from 18px
    on `lap` breakpoint to 24px on `desk` breakpoint.

    You can also redefine the min- and max breakpoints like this:

    padding: responsive.clamp(18px, 24px, desk, wall);
    ========================================================================= */

@function clamp($size-min: 16px, $size-max: 20px, $min-bp: lap, $max-bp: desk) {
  $return: $size-min;

  @if map.has-key(defaults.$breakpoints, $min-bp) and map.has-key(defaults.$breakpoints, $max-bp) {
    @if (math.unit($size-min) == 'px' and math.unit($size-max) == 'px' and math.unit(map.get(defaults.$breakpoints, $min-bp)) == 'px' and math.unit(map.get(defaults.$breakpoints, $max-bp)) == 'px') {
      $min-bp-value: map.get(defaults.$breakpoints, $min-bp);
      $max-bp-value: map.get(defaults.$breakpoints, $max-bp);

      $min-bp-rem-unitless: functions.strip-units(rem.convert($min-bp-value));
      $max-bp-rem-unitless: functions.strip-units(rem.convert($max-bp-value));

      $size-min-rem: rem.convert($size-min);
      $size-min-rem-unitless: functions.strip-units($size-min-rem);
      $size-max-rem: rem.convert($size-max);
      $size-max-rem-unitless: functions.strip-units($size-max-rem);

      $slope: ($size-max-rem-unitless - $size-min-rem-unitless) / ($max-bp-rem-unitless - $min-bp-rem-unitless);
      $yAxisIntersection: -($min-bp-rem-unitless) * $slope + $size-min-rem-unitless;

      $return: #{clamp}($size-min-rem, #{$yAxisIntersection * 1rem} #{' + '} #{($slope * 100) * 1vw}, $size-max-rem);
    } @else {
      @error '$size-min, $size-max, $min-bp and $max-bp should be defined in px.';
    }
  } @else {
    @error '`$min-bp: #{$min-bp}` or `$max-bp: #{$max-bp}` should be defined in `defaults.$breakpoints`';
  }

  @return $return;
}



/*  in-breakpoint
    A little helper mixin to quickly create responsive variants of a certain
    selector. The mixin's `@content` will be also applied to the parent selector.

    Example usage:
    $YOURMODULE-in-breakpoint: (
      from: lap desk,
      until: desk,
    );
    .your-module {
      @include responsive.in-breakpoint($YOURMODULE-in-breakpoint) {
        outline: 1px solid #ff0000;
      }
    }
    ========================================================================= */


@mixin in-breakpoint($breakpoints) {
  @content;

  @each $breakpoint in $breakpoints {
    @if ((list.nth($breakpoint, 1) == 'from' or list.nth($breakpoint, 1) == 'until') and list.nth($breakpoint, 2)) {
      // if the second argument is a list, loop over it
      @if meta.type-of(list.nth($breakpoint, 2)) == 'list' {
        @each $point in list.nth($breakpoint, 2) {
          @include supple-mq($point, list.nth($breakpoint, 1)) {
            &#{defaults.$responsive-modifier}#{list.nth($breakpoint, 1)}-#{$point} {
              @content;
            }
          }
        }
      } @else {
        @include supple-mq(list.nth($breakpoint, 2), list.nth($breakpoint, 1)) {
          &#{defaults.$responsive-modifier}#{list.nth($breakpoint, 1)}-#{list.nth($breakpoint, 2)} {
            @content;
          }
        }
      }
    } @else {
      @include supple-mq($breakpoint) {
        &#{defaults.$responsive-modifier}from-#{$breakpoint} {
          @content;
        }
      }
    }
  }
}
