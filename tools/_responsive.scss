/*  =========================================================================
    tools.responsive
    desc
    ========================================================================= */

/*  Use/Forward rules
    `@use` or `@forward` everything you need here from other files.
    These can include variables, mixins & other includes.
    ========================================================================= */

@use 'sass:list';
@use '../settings/defaults';
@use '../vendor/sass-mq/mq' as sassmq;



/*  Wrappers to sass-mq
    ========================================================================= */

@mixin mq($args...) {
  @include sassmq.mq($args...) {
    @content;
  }
}

@mixin add-breakpoint($args...) {
  @include sassmq.mq-add-breakpoint($args...);
}

@mixin show-breakpoints($args...) {
  @include sassmq.mq-show-breakpoints($args...);
}



/*  supple-mq
    A little wrapper around sass-mq which alows us to pass in a string based
    direction instead of direction variable.

    Example usage:
    @include supple-mq(wall, until) {
      outline: 1px solid #ff0000;
    }
    ========================================================================= */

@mixin supple-mq($name, $direction: from) {
  @if ($direction == from) {
    @include mq($from: $name) {
      @content;
    }
  } @else if ($direction == until) {
    @include mq($until: $name) {
      @content;
    }
  } @else {
    @error '#{$direction} is not a valid sass-mq direction';
  }
}


/*  in-breakpoint
    A little helper mixin to quickly create responsive variants of a certain
    selector.

    Example usage:
    $YOURMODULE-in-breakpoint: (
      from: lap desk,
      until: desk,
    );
    @include in-breakpoint($YOURMODULE-in-breakpoint, '.your-selector') {
      outline: 1px solid #ff0000;
    }
    ========================================================================= */

/* stylelint-disable max-nesting-depth */
@mixin in-breakpoint($breakpoints, $selector) {
  @if ($breakpoints and $selector) {
    @each $breakpoint in $breakpoints {
      @if ((list.nth($breakpoint, 1) == 'from' or list.nth($breakpoint, 1) == 'until') and list.nth($breakpoint, 2)) {
        // if the second argument is a list, loop over it
        @if meta.type-of(list.nth($breakpoint, 2)) == 'list' {
          @each $point in list.nth($breakpoint, 2) {
            @include supple-mq($point, list.nth($breakpoint, 1)) {
              #{$selector}#{defaults.$responsive-modifier}#{list.nth($breakpoint, 1)}-#{$point} {
                @content;
              }
            }
          }
        } @else {
          @include supple-mq(list.nth($breakpoint, 2), list.nth($breakpoint, 1)) {
            #{$selector}#{defaults.$responsive-modifier}#{list.nth($breakpoint, 1)}-#{list.nth($breakpoint, 2)} {
              @content;
            }
          }
        }
      } @else {
        @include supple-mq($breakpoint) {
          #{$selector}#{defaults.$responsive-modifier}from-#{$breakpoint} {
            @content;
          }
        }
      }
    }
  } @else {
    @error '$breakpoints and $selector arguments are required';
  }
}

/* stylelint-enable */
